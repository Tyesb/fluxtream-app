Index: fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesBodytrackResponder.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.fluxtream.connectors.moves;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.TimeZone;\nimport com.fluxtream.SimpleTimeInterval;\nimport com.fluxtream.TimeInterval;\nimport com.fluxtream.TimeUnit;\nimport com.fluxtream.connectors.Connector;\nimport com.fluxtream.connectors.ObjectType;\nimport com.fluxtream.connectors.bodytrackResponders.AbstractBodytrackResponder;\nimport com.fluxtream.connectors.vos.AbstractFacetVO;\nimport com.fluxtream.domain.AbstractFacet;\nimport com.fluxtream.domain.ApiKey;\nimport com.fluxtream.domain.GuestSettings;\nimport com.fluxtream.mvc.models.TimespanModel;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MovesBodytrackResponder extends AbstractBodytrackResponder {\n\n    @Override\n    public List<TimespanModel> getTimespans(final long startMillis, final long endMillis, final ApiKey apiKey, final String channelName) {\n        List<TimespanModel> items = new ArrayList<TimespanModel>();\n        final TimeInterval timeInterval = new SimpleTimeInterval(startMillis, endMillis, TimeUnit.ARBITRARY, TimeZone.getTimeZone(\"UTC\"));\n        ObjectType[] objectTypes = apiKey.getConnector().objectTypes();\n\n        for (ObjectType objectType : objectTypes){\n            String objectTypeName = apiKey.getConnector().getName() + \"-\" + objectType.getName();\n            if (objectType.getName().equals(\"move\")){\n                List<AbstractFacet> facets = getFacetsInTimespan(timeInterval,apiKey,objectType);\n                for (AbstractFacet facet : facets){\n                    MovesMoveFacet moveFacet = (MovesMoveFacet) facet;\n                    for (MovesActivity activity : moveFacet.getActivities()){\n                        items.add(new TimespanModel(activity.start,activity.end,activity.activity,objectTypeName));\n                    }\n                }\n\n            }\n            else if (objectType.getName().equals(\"place\")){\n                List<AbstractFacet> facets = getFacetsInTimespan(timeInterval,apiKey,objectType);\n                for (AbstractFacet facet : facets){\n                    MovesPlaceFacet place = (MovesPlaceFacet) facet;\n                    items.add(new TimespanModel(place.start,place.end,\"place\",objectTypeName));\n                }\n            }\n        }\n        return items;\n    }\n\n    @Override\n    public List<AbstractFacetVO<AbstractFacet>> getFacetVOs(final GuestSettings guestSettings, final ApiKey apiKey, final String objectTypeName, final long start, final long end, final String value) {\n        Connector connector = apiKey.getConnector();\n        String[] objectTypeNameParts = objectTypeName.split(\"-\");\n        ObjectType objectType = null;\n        for (ObjectType ot : connector.objectTypes()){\n            if (ot.getName().equals(objectTypeNameParts[1])){\n                objectType = ot;\n                break;\n            }\n        }\n        if (objectType == null || (objectType.getName().equals(\"place\") && !\"place\".equals(value)))\n            return new ArrayList<AbstractFacetVO<AbstractFacet>>();\n\n        TimeInterval timeInterval = metadataService.getArbitraryTimespanMetadata(apiKey.getGuestId(), start, end).getTimeInterval();\n\n        List<AbstractFacet> facets = getFacetsInTimespan(timeInterval,apiKey,objectType);\n\n        if (objectType.getName().equals(\"move\")){\n            MovesMoveFacet move;\n            for (Iterator<AbstractFacet> i = facets.iterator(); i.hasNext();){\n                move = (MovesMoveFacet) i.next();\n                boolean found = false;\n                for (MovesActivity activity : move.getActivities()){\n                    if (activity.activity.equals(value)){\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found)\n                   i.remove();\n            }\n        }\n\n        List<AbstractFacetVO<AbstractFacet>> facetVOsForFacets = getFacetVOsForFacets(facets, timeInterval, guestSettings);\n        facetVOsForFacets = dedup(facetVOsForFacets);\n        return facetVOsForFacets;\n    }\n\n    private List<AbstractFacetVO<AbstractFacet>> dedup(final List<AbstractFacetVO<AbstractFacet>> facetVOs) {\n        List<AbstractFacetVO<AbstractFacet>> deduped = new ArrayList<AbstractFacetVO<AbstractFacet>>();\n\n        there: for (AbstractFacetVO<AbstractFacet> facetVO : facetVOs) {\n            AbstractMovesFacetVO f = (AbstractMovesFacetVO) facetVO;\n            for (AbstractFacetVO<AbstractFacet> uniqueFacet : deduped) {\n                AbstractMovesFacetVO u = (AbstractMovesFacetVO) uniqueFacet;\n                if (u.type.equals(f.type)&&u.start==f.start) {\n                    if (u.end>f.end)\n                        continue there;\n                    else {\n                        deduped.remove(u);\n                        deduped.add(f);\n                        continue there;\n                    }\n                }\n            }\n            deduped.add(f);\n        }\n        return deduped;\n    }\n\n}\n
===================================================================
--- fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesBodytrackResponder.java	(date 1388785969000)
+++ fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesBodytrackResponder.java	(revision )
@@ -42,7 +42,11 @@
                 List<AbstractFacet> facets = getFacetsInTimespan(timeInterval,apiKey,objectType);
                 for (AbstractFacet facet : facets){
                     MovesPlaceFacet place = (MovesPlaceFacet) facet;
-                    items.add(new TimespanModel(place.start,place.end,"place",objectTypeName));
+                    final TimespanModel placeTimespanModel = new TimespanModel(place.start, place.end, "place", objectTypeName);
+                    // adding info needed to construct dynamic (template-based) iconURL
+                    placeTimespanModel.addParam("apiKeyId", String.valueOf(place.apiKeyId));
+                    placeTimespanModel.addParam("id", String.valueOf(place.getId()));
+                    items.add(placeTimespanModel);
                 }
             }
         }
Index: fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesUpdater.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.fluxtream.connectors.moves;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.TimeZone;\nimport java.util.UUID;\nimport java.util.Random;\nimport com.fluxtream.aspects.FlxLogger;\nimport com.fluxtream.connectors.Connector;\nimport com.fluxtream.connectors.annotations.Updater;\nimport com.fluxtream.connectors.location.LocationFacet;\nimport com.fluxtream.connectors.runkeeper.RunKeeperFitnessActivityFacet;\nimport com.fluxtream.connectors.updaters.AbstractUpdater;\nimport com.fluxtream.connectors.updaters.RateLimitReachedException;\nimport com.fluxtream.connectors.updaters.UpdateFailedException;\nimport com.fluxtream.connectors.updaters.UpdateInfo;\nimport com.fluxtream.domain.AbstractFacet;\nimport com.fluxtream.domain.AbstractLocalTimeFacet;\nimport com.fluxtream.domain.ApiKey;\nimport com.fluxtream.domain.ChannelMapping;\nimport com.fluxtream.domain.Notification;\nimport com.fluxtream.domain.UpdateWorkerTask;\nimport com.fluxtream.services.ApiDataService;\nimport com.fluxtream.services.ConnectorUpdateService;\nimport com.fluxtream.services.JPADaoService;\nimport com.fluxtream.services.MetadataService;\nimport com.fluxtream.services.impl.BodyTrackHelper;\nimport com.fluxtream.services.impl.BodyTrackHelper.ChannelStyle;\nimport com.fluxtream.services.impl.BodyTrackHelper.MainTimespanStyle;\nimport com.fluxtream.services.impl.BodyTrackHelper.TimespanStyle;\nimport com.fluxtream.utils.HttpUtils;\nimport com.fluxtream.utils.JPAUtils;\nimport com.fluxtream.utils.TimeUtils;\nimport com.fluxtream.utils.UnexpectedHttpResponseCodeException;\nimport com.fluxtream.utils.Utils;\nimport net.sf.json.JSONArray;\nimport net.sf.json.JSONObject;\nimport org.apache.http.Header;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.client.ResponseHandler;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.BasicResponseHandler;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeConstants;\nimport org.joda.time.format.DateTimeFormat;\nimport org.joda.time.format.DateTimeFormatter;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\nimport org.springframework.transaction.annotation.Transactional;\n\n/**\n * User: candide\n * Date: 17/06/13\n * Time: 16:50\n */\n@Component\n@Updater(prettyName = \"Moves\", value = 144, objectTypes = {LocationFacet.class, MovesMoveFacet.class, MovesPlaceFacet.class}, bodytrackResponder = MovesBodytrackResponder.class,\n         defaultChannels = {\"moves.data\"})\npublic class MovesUpdater extends AbstractUpdater {\n    static FlxLogger logger = FlxLogger.getLogger(AbstractUpdater.class);\n\n    @Autowired\n    BodyTrackHelper bodyTrackHelper;\n\n    final static String host = \"https://api.moves-app.com/api/v1\";\n    final static String updateDateKeyName = \"lastDate\";\n\n    // Fixup the place data for a full week into the past\n    final static int pastDaysToUpdatePlaces = 7;\n\n    public static DateTimeFormatter compactDateFormat = DateTimeFormat.forPattern(\"yyyyMMdd\");\n    public static DateTimeFormatter timeStorageFormat = DateTimeFormat.forPattern(\"yyyyMMdd'T'HHmmss'Z'\");\n    public static DateTimeFormatter httpResponseDateFormat = DateTimeFormat.forPattern(\"EEE, dd MMM yyyy HH:mm:ss ZZZ\");\n\n    // This holds onto the next time that we know quota is available.  The quota for Moves is global\n    // across all the instances using a given consumer key.  The MovesUpdater is a singleton, so\n    // all the Moves updates in a given system will share this same object.  The access to this variable is\n    // synchronized such that the first thread that finds out that the quota has been exceeded for now\n    // can be treated specially with respect to handling rescheduling.  Subsequent threads that find out\n    // that quotaAvailableTime has already been updated beyond the present can either wait until more quota\n    // is available or yield until a later time, but should not try to handle rescheduling.\n    private volatile long quotaAvailableTime=0;\n\n    // This is the maximum number of millis we're willing to wait for quota to become available.  By default it's a\n    // minute\n    private long maxQuotaWaitMillis=DateTimeConstants.MILLIS_PER_MINUTE;\n\n    @Autowired\n    MovesController controller;\n\n    @Autowired\n    MetadataService metadataService;\n\n    @Autowired\n    JPADaoService jpaDaoService;\n\n    @Autowired\n    ConnectorUpdateService connectorUpdateService;\n\n\n    @Override\n    protected void updateConnectorDataHistory(final UpdateInfo updateInfo) throws Exception, UpdateFailedException {\n        // Get the date for starting the update.  This will either be a stored date from a previous run\n        // of the updater or the user's registration date.\n        String updateStartDate = getUpdateStartDate(updateInfo);\n\n        updateMovesData(updateInfo, updateStartDate, 0);\n    }\n\n    // Get/update moves data for the range of dates starting from the stored date of the last update.\n    // Do a maximum of pastDaysToUpdatePlaces days of fixup on earlier dates to pickup user-initiated changes\n    @Override\n    protected void updateConnectorData(final UpdateInfo updateInfo) throws Exception, UpdateFailedException {\n        // Get the date for starting the update.  This will either be a stored date from a previous run\n        // of the updater or the user's registration date.\n        String updateStartDate = getUpdateStartDate(updateInfo);\n\n        updateMovesData(updateInfo, updateStartDate, pastDaysToUpdatePlaces);\n    }\n\n    public String getUserRegistrationDate(UpdateInfo updateInfo) throws Exception, UpdateFailedException {\n        // Check first if we already have a user registration date stored in apiKeyAttributes as userRegistrationDate.\n        // userRegistrationDate is stored in storage format (yyyy-mm-dd)\n        String userRegistrationKeyName = \"userRegistrationDate\";\n        String userRegistrationDate = guestService.getApiKeyAttribute(updateInfo.apiKey,userRegistrationKeyName);\n\n        // The first time we do this there won't be a stored userRegistrationDate yet.  In that case get the\n        // registration date from a Moves API call\n        if(userRegistrationDate == null) {\n            long currentTime = System.currentTimeMillis();\n            String accessToken = controller.getAccessToken(updateInfo.apiKey);\n            String query = host + \"/user/profile?access_token=\" + accessToken;\n            try {\n                final String fetched = fetchMovesAPI(updateInfo, query);\n                countSuccessfulApiCall(updateInfo.apiKey, updateInfo.objectTypes, currentTime, query);\n                JSONObject json = JSONObject.fromObject(fetched);\n                if (!json.has(\"profile\"))\n                    throw new Exception(\"no profile\");\n                final JSONObject profile = json.getJSONObject(\"profile\");\n                if (!profile.has(\"firstDate\"))\n                    throw new Exception(\"no firstDate in profile\");\n                String compactRegistrationDate = profile.getString(\"firstDate\");\n\n                if(compactRegistrationDate!=null) {\n                    // The format of firstDate returned by the Moves API is compact (yyyymmdd).  Convert to\n                    // the storage format (yyyy-mm-dd) for consistency\n                    userRegistrationDate = toStorageFormat(compactRegistrationDate);\n\n                    // Cache registrationDate so we don't need to do an API call next time\n                    guestService.setApiKeyAttribute(updateInfo.apiKey, userRegistrationKeyName, userRegistrationDate);\n                }\n            } catch (UnexpectedHttpResponseCodeException e) {\n                // Couldn't get user registration date\n                StringBuilder sb = new StringBuilder(\"module=updateQueue component=updater action=MovesUpdater.getUserRegistrationDate\")\n                        .append(\" message=\\\"exception while retrieving UserRegistrationDate\\\" connector=\")\n                        .append(updateInfo.apiKey.getConnector().toString()).append(\" guestId=\")\n                        .append(updateInfo.apiKey.getGuestId())\n                        .append(\" stackTrace=<![CDATA[\").append(Utils.stackTrace(e)).append(\"]]>\");;\n                logger.info(sb.toString());\n\n                countFailedApiCall(updateInfo.apiKey, updateInfo.objectTypes, currentTime, query, Utils.stackTrace(e),\n                                   e.getHttpResponseCode(), e.getHttpResponseMessage());\n\n                // The update failed.  We don't know if this is permanent or temporary.\n                // Throw the appropriate exception.\n                throw new UpdateFailedException(e);\n\n            } catch (RateLimitReachedException e) {\n                // Couldn't get user registration date, rate limit reached\n                StringBuilder sb = new StringBuilder(\"module=updateQueue component=updater action=MovesUpdater.getUserRegistrationDate\")\n                        .append(\" message=\\\"rate limit reached while retrieving UserRegistrationDate\\\" connector=\")\n                        .append(updateInfo.apiKey.getConnector().toString()).append(\" guestId=\")\n                        .append(updateInfo.apiKey.getGuestId())\n                        .append(\" stackTrace=<![CDATA[\").append(Utils.stackTrace(e)).append(\"]]>\");;\n                logger.info(sb.toString());\n\n                countFailedApiCall(updateInfo.apiKey, updateInfo.objectTypes, currentTime, query, Utils.stackTrace(e),\n                                   429, \"Rate limit reached\");\n\n                // Rethrow the rate limit reached exception\n                throw e;\n\n            } catch (IOException e) {\n                // Couldn't get user registration date\n                StringBuilder sb = new StringBuilder(\"module=updateQueue component=updater action=MovesUpdater.getUserRegistrationDate\")\n                        .append(\" message=\\\"exception while retrieving UserRegistrationDate\\\" connector=\")\n                        .append(updateInfo.apiKey.getConnector().toString()).append(\" guestId=\")\n                        .append(updateInfo.apiKey.getGuestId())\n                        .append(\" stackTrace=<![CDATA[\").append(Utils.stackTrace(e)).append(\"]]>\");;\n                logger.info(sb.toString());\n\n                reportFailedApiCall(updateInfo.apiKey, updateInfo.objectTypes, currentTime, query, Utils.stackTrace(e), \"I/O\");\n\n                // The update failed.  We don't know if this is permanent or temporary.\n                // Throw the appropriate exception.\n                throw new UpdateFailedException(e);\n            }\n        }\n        return userRegistrationDate;\n    }\n\n    public String getUpdateStartDate(UpdateInfo updateInfo) throws Exception\n    {\n        // Check first if we already have a date stored in apiKeyAttributes as updateDateKeyName.\n        // In the case of a failure the updater will store the date\n        // that failed and start there next time.  In the case of a successfully completed update it will store\n        // the date of the last day that returned partial data\n        // The updateDateKeyName attribute is stored in storage format (yyyy-mm-dd)\n        String updateStartDate = guestService.getApiKeyAttribute(updateInfo.apiKey, updateDateKeyName);\n\n        // The first time we do this there won't be an apiKeyAttribute yet.  In that case get the\n        // registration date for the user and store that.\n        if(updateStartDate == null) {\n            updateStartDate = getUserRegistrationDate(updateInfo);\n\n            // Store in the apiKeyAttribute for next time\n            guestService.setApiKeyAttribute(updateInfo.apiKey, updateDateKeyName, updateStartDate);\n        }\n        return updateStartDate;\n    }\n\n\n\n    // Get/update moves data for the range of dates start\n    protected void updateMovesData(final UpdateInfo updateInfo, String fullUpdateStartDate, int fixupDateNum) throws Exception {\n        // Calculate the lists of days to update. Moves only updates its data for a given day when either the user\n        // manually opens the application or when the phone notices that it's past midnight local time.  The former\n        // action generates partial data for the day and the latter generates finalized data for that day with respect\n        // to the parsing of the move and place segments and the generation of the GPS data points.  However, the\n        // user is able to go back and modify things like place IDs and movemet segment types (\"wlk', 'trp', or 'cyc').\n        //\n        // fullUpdateStartDate is the last date that we had partial data for previous time we did an update (user had opened app\n        // but the phone presumably hadn't done the cross-midnight recompute (NOTE: this assumption may be flawed if our\n        // inferred user timezone differs from the phone's idea of its own timezone).  We will do a full update\n        // including GPS points, for that date and all future dates up to and including today as computed in the\n        // timezone we currently infer for the user.\n        //\n        // The days prior to fullUpdateStartDate should presumably have imported\n        // complete updates during a previous update so we don't need to reimport the GPS data points.  However,\n        // we do need to import the move/place segments and reconcile them with our stored versions since the\n        // user may have tweaked some of them.  We currently arbitrarily re-import the pastDaysToUpdatePlaces prior days to do this\n        // fixup operation.\n\n        // getDatesSince and getDatesBefore both take their arguments and return their list of dates in storage\n        // format (yyyy-mm-dd).  The list returned by getDatesSince includes the date passed in (in this case fullUpdateStartDate)\n        // but getDatesBefore does not, so fullUpdateStartDate is processed as a full update.\n\n        List<ChannelMapping> mappings = bodyTrackHelper.getChannelMappings(updateInfo.apiKey);\n        if (mappings.size() == 0){\n            ChannelMapping mapping = new ChannelMapping();\n            mapping.deviceName = \"moves\";\n            mapping.channelName = \"data\";\n            mapping.timeType = ChannelMapping.TimeType.gmt;\n            mapping.channelType = ChannelMapping.ChannelType.timespan;\n            mapping.guestId = updateInfo.getGuestId();\n            mapping.apiKeyId = updateInfo.apiKey.getId();\n            bodyTrackHelper.persistChannelMapping(mapping);\n\n            ChannelStyle channelStyle = new ChannelStyle();\n            channelStyle.timespanStyles = new MainTimespanStyle();\n            channelStyle.timespanStyles.defaultStyle = new TimespanStyle();\n            channelStyle.timespanStyles.defaultStyle.fillColor = \"#e9e9e9\";\n            channelStyle.timespanStyles.defaultStyle.borderColor = \"#c9c9c9\";\n            channelStyle.timespanStyles.defaultStyle.borderWidth = 2;\n            channelStyle.timespanStyles.defaultStyle.top = 0.0;\n            channelStyle.timespanStyles.defaultStyle.bottom = 1.0;\n            channelStyle.timespanStyles.values = new HashMap();\n\n            TimespanStyle stylePart = new TimespanStyle();\n            stylePart.top = 0.25;\n            stylePart.bottom = 0.75;\n            stylePart.fillColor = \"#23ee70\";\n            stylePart.borderColor = \"#03ce50\";\n            channelStyle.timespanStyles.values.put(\"wlk\",stylePart);\n\n            stylePart = new TimespanStyle();\n            stylePart.top = 0.25;\n            stylePart.bottom = 0.75;\n            stylePart.fillColor = \"#e674ec\";\n            stylePart.borderColor = \"#c654cc\";\n            channelStyle.timespanStyles.values.put(\"run\",stylePart);\n\n            stylePart = new TimespanStyle();\n            stylePart.top = 0.25;\n            stylePart.bottom = 0.75;\n            stylePart.fillColor = \"#68abef\";\n            stylePart.borderColor = \"#488bcf\";\n            channelStyle.timespanStyles.values.put(\"cyc\",stylePart);\n\n            stylePart = new TimespanStyle();\n            stylePart.top = 0.25;\n            stylePart.bottom = 0.75;\n            stylePart.fillColor = \"#8f8f8d\";\n            stylePart.borderColor = \"#6f6f6d\";\n            channelStyle.timespanStyles.values.put(\"trp\",stylePart);\n\n            bodyTrackHelper.setBuiltinDefaultStyle(updateInfo.getGuestId(),\"moves\",\"data\",channelStyle);\n        }\n        final List<String> fullUpdateDates = getDatesSince(fullUpdateStartDate);\n\n        // For the dates that aren't yet completed (fullUpdateStartDate through today), createOrUpdate with trackpoints.\n        // createOrUpdateData will also update updateDateKeyName to set the start time for the next update as it goes\n        // to be the last date that had non-empty data when withTrackpoints is true (meaning we're moving forward in time)\n        String maxDateWithData = createOrUpdateData(fullUpdateDates, updateInfo, true);\n\n        // If fixupDateNum>0, do createOrUpdate without trackpoints for the fixupDateNum dates prior to\n        // fullUpdateStartDate\n        if(fixupDateNum>0) {\n            final List<String> fixupDates = getDatesBefore(fullUpdateStartDate, fixupDateNum);\n            createOrUpdateData(fixupDates, updateInfo, false);\n        }\n    }\n\n    private String fetchStorylineForDate(final UpdateInfo updateInfo, final String date, final boolean withTrackpoints) throws Exception {\n        long then = System.currentTimeMillis();\n        String fetched = null;\n        String compactDate = toCompactDateFormat(date);\n        String fetchUrl = \"not set yet\";\n        try {\n            String accessToken = controller.getAccessToken(updateInfo.apiKey);\n            fetchUrl = String.format(host + \"/user/storyline/daily/%s?trackPoints=%s&access_token=%s\",\n                                            compactDate, withTrackpoints, accessToken);\n            fetched = fetchMovesAPI(updateInfo, fetchUrl);\n            countSuccessfulApiCall(updateInfo.apiKey, updateInfo.objectTypes, then, fetchUrl);\n        } catch (UnexpectedHttpResponseCodeException e) {\n            countFailedApiCall(updateInfo.apiKey, updateInfo.objectTypes, then, fetchUrl, Utils.stackTrace(e),\n                               e.getHttpResponseCode(), e.getHttpResponseMessage());\n\n            // The update failed.  We don't know if this is permanent or temporary.\n            // Throw the appropriate exception.\n            throw new UpdateFailedException(e);\n        } catch (RateLimitReachedException e) {\n            // Couldn't fetch storyline, rate limit reached\n            countFailedApiCall(updateInfo.apiKey, updateInfo.objectTypes, then, fetchUrl, Utils.stackTrace(e),\n                               429, \"Rate limit reached\");\n\n            // Rethrow the rate limit reached exception\n            throw e;\n\n\n        } catch (IOException e) {\n            countFailedApiCall(updateInfo.apiKey, updateInfo.objectTypes, then, fetchUrl, Utils.stackTrace(e), -1, \"I/O\");\n\n            // The update failed.  We don't know if this is permanent or temporary.\n            // Throw the appropriate exception.\n            throw new UpdateFailedException(e);\n        }\n        return fetched;\n    }\n\n    // Return true if we are the first to update the quotaAvailableTime to the new value, and\n    // false otherwise.  In the case that nextQuotaAvailableTime is in the future, the first instance to\n    // update it has the responsibility to deal with rescheduling.  The other instances should wait or defer.\n    private boolean tryUpdateQuotaAvailableTime(final long nextQuotaAvailableTime) {\n        boolean retVal = false;\n\n        // First check if we're obviously not the first to set the most up-to-date quota time.  We\n        // don't need to lock quotaAvailableTime to do that since we'll check it again if we're\n        // possibly the first\n        if(quotaAvailableTime >= nextQuotaAvailableTime)\n            return false;\n\n        // We're potentially the first, check again inside a synchronized block.\n        // If we're still the first, set quotaAvailableTime and return true.  If another\n        // instance beat us, return false.\n        synchronized (this) {\n            if(quotaAvailableTime >= nextQuotaAvailableTime)\n                return false;\n            else {\n                quotaAvailableTime = nextQuotaAvailableTime;\n                return true;\n            }\n\n        }\n    }\n\n    private long getQuotaAvailableTime()\n    {\n        synchronized (this) {\n            return(quotaAvailableTime);\n        }\n    }\n\n    // Check if we would expect quota to be currently available for making a Moves API call.\n    // If so, return 0.  If not, return the milliseconds between now and when we'd expect quota to\n    // be available.  This isn't a guarantee that we won't run out of quota before the call happens,\n    // it's just an optimization in the case where there's a current thread and a short quota delay so\n    // we may avoid a 429/retry cycle\n    private long getQuotaWaitTime() {\n        long now = System.currentTimeMillis();\n        long quotaAvailableIn = getQuotaAvailableTime()-now;\n        if(quotaAvailableIn<0)\n            return 0;\n        return quotaAvailableIn;\n    }\n\n    // Generate a time that's randomly distributed through the hour after quotaAvailableTime\n    // to do some load balancing\n    private long getRandomRescheduleTime() {\n        Random generator = new Random();\n        long randomDelayMillis = (long)(generator.nextInt(DateTimeConstants.MILLIS_PER_HOUR));\n        return getQuotaAvailableTime() + randomDelayMillis;\n    }\n\n    // Before call:  Check quotaAvailableTime to see if we can reasonably expect a call to succeed.\n    // After call: Check for X-RateLimit-MinuteRemaining and X-RateLimit-HourRemaining to determine\n    // if we need to change quotaAvailableTime.  If we try to change it and succeed, we should take care\n    // of rescheduling.  If we try to change it and someone else beat us to it, we should just defer\n    private String fetchMovesAPI(final UpdateInfo updateInfo, final String url)\n            throws UnexpectedHttpResponseCodeException, UpdateFailedException, RateLimitReachedException, IOException {\n        String content=null;\n        HttpClient client = env.getHttpClient();\n\n        // Check if we would expect to have enough quota to make this call\n        long waitTime = getQuotaWaitTime();\n        if (waitTime>0) {\n            do {\n                // We don't currently have quota available.  If it'll be available in < 1 minute, just wait.\n                // Otherwise, quit and retry later\n                if(waitTime > maxQuotaWaitMillis) {\n                    // We're not willing to wait that long, reschedule\n                    System.out.println(new StringBuilder().append(\"MOVES: guestId=\").append(updateInfo.getGuestId()).append(\", waitTime=\").append(waitTime).append(\", RESCHEDULING\").toString());\n                    // Set the reset time info in updateInfo so that we get scheduled for when the quota becomes available\n                    // + a random number of minutes in the range of 0 to 60 to spread the load of lots of competing\n                    // updaters across the next hour\n                    updateInfo.setResetTime(\"moves\", getRandomRescheduleTime());\n                    throw new RateLimitReachedException();\n                }\n                // We are willing to wait that long\n                System.out.println(new StringBuilder().append(\"MOVES: guestId=\").append(updateInfo.getGuestId()).append(\", waitTime=\").append(waitTime).append(\", WAITING\").toString());\n\n                try { Thread.currentThread().sleep(waitTime); }\n                catch(Throwable e) {\n                    e.printStackTrace();\n                    throw new RuntimeException(\"Unexpected error waiting to enforce rate limits.\");\n                }\n                waitTime = getQuotaWaitTime();\n            } while (waitTime>0);\n        }\n\n        // By the time we get to here, we should likely have quota available\n        try {\n            HttpGet get = new HttpGet(url);\n\n            HttpResponse response = client.execute(get);\n\n            // Get the millisecond time of the next available bit of quota.  These fields will be populated for\n            // status 200 or status 429 (over quota).  Other responses may not have them, in which case\n            // responseToQuotaAvailableTime will return -1.  Ignore that case.\n            long nextQuotaAvailableTime = responseToQuotaAvailableTime(updateInfo, response);\n\n            // Update the quotaAvailableTime and check if we're the first to learn that we just blew quota\n            boolean firstToUpdate = tryUpdateQuotaAvailableTime(nextQuotaAvailableTime);\n            long now = System.currentTimeMillis();\n\n            if(firstToUpdate && nextQuotaAvailableTime>now) {\n                // We're the first to find out that quota is gone.  We may or may not have succeeded on this call,\n                // depending on the status code.  Regardless of the status code, fix the scheduling of moves updates\n                // that would otherwise happen before the next quota window opens up.\n                List<UpdateWorkerTask> updateWorkerTasks = connectorUpdateService.getScheduledUpdateWorkerTasksForConnectorNameBeforeTime(\"moves\", nextQuotaAvailableTime);\n                for (int i=0; i<updateWorkerTasks.size(); i++) {\n                    UpdateWorkerTask updateWorkerTask = updateWorkerTasks.get(i);\n                    // Space the tasks 30 seconds apart so they don't all try to start at the same time\n                    long rescheduleTime = nextQuotaAvailableTime + i*(DateTimeConstants.MILLIS_PER_SECOND*30);\n\n                    // Update the scheduled execution time for any moves tasks that would otherwise happen during\n                    // the current quota outage far enough into the future that we should have quota available by then.\n                    // If there's more than one pending, stagger them by a few minutes so that they don't all try to\n                    // happen at once.  The reason the \"incrementRetries\" arg is true is that that appears to be the\n                    // way to prevent spawning a duplicate entry in the UpdateWorkerTask table.\n                    connectorUpdateService.reScheduleUpdateTask(updateWorkerTask.getId(),\n                                                                rescheduleTime,\n                                                                true,null);\n\n                    logger.info(\"module=movesUpdater component=fetchMovesAPI action=fetchMovesAPI\" +\n                                \" message=\\\"Rescheduling due to quota limit: \" +\n                                updateWorkerTask + \"\\\" newUpdateTime=\" + rescheduleTime);\n                }\n            }\n\n\n            int statusCode = response.getStatusLine().getStatusCode();\n            if (statusCode == HttpStatus.SC_OK) {\n                ResponseHandler<String> responseHandler = new BasicResponseHandler();\n                content = responseHandler.handleResponse(response);\n            }\n            else if(statusCode == 401) {\n                // Unauthorized, so this is never going to work\n                // Notify the user that the tokens need to be manually renewed\n                notificationsService.addNamedNotification(updateInfo.getGuestId(), Notification.Type.WARNING, connector().statusNotificationName(),\n                                                      \"Heads Up. We failed in our attempt to update your Moves connector.<br>\" +\n                                                      \"Please head to <a href=\\\"javascript:App.manageConnectors()\\\">Manage Connectors</a>,<br>\" +\n                                                      \"scroll to the Moves connector, and renew your tokens (look for the <i class=\\\"icon-resize-small icon-large\\\"></i> icon)\");\n                // Record permanent failure since this connector won't work again until\n                // it is reauthenticated\n                guestService.setApiKeyStatus(updateInfo.apiKey.getId(), ApiKey.Status.STATUS_PERMANENT_FAILURE, null);\n                throw new UpdateFailedException(\"Unauthorized access\", true);\n            }\n            else if(statusCode == 429) {\n                // Over quota, so this API attempt didn't work\n                // Set the reset time info in updateInfo so that we get scheduled for when the quota becomes available\n                updateInfo.setResetTime(\"moves\", getQuotaAvailableTime());\n                throw new RateLimitReachedException();\n            }\n            else {\n                throw new UnexpectedHttpResponseCodeException(response.getStatusLine().getStatusCode(),\n                                                              response.getStatusLine().getReasonPhrase());\n            }\n        }\n        finally {\n            client.getConnectionManager().shutdown();\n        }\n        return content;\n    }\n\n    // Check for Date, X-RateLimit-MinuteRemaining, and X-RateLimit-HourRemaining to determine\n    // the quotaAvailableTime.  If X-RateLimit-MinuteRemaining and X-RateLimit-HourRemaining are\n    // both > 0, then quotaAvailableTime is the start of the minute represented by the Date header.\n    // If X-RateLimit-HourRemaining is zero, then quotaAvailableTime is the start of the next hour\n    // after Date.  If X-RateLimit-HourRemaining is > 0 but X-RateLimit-MinuteRemaining is zero,\n    // then quotaAvailableTime is the start of the minute after Date.\n    // Returns -1 if there's a problem.\n    private static long responseToQuotaAvailableTime(final UpdateInfo updateInfo, final HttpResponse response)\n    {\n        final Header[] dateHeader = response.getHeaders(\"Date\");\n        final Header[] minuteRemainingHeader = response.getHeaders(\"X-RateLimit-MinuteRemaining\");\n        final Header[] hourRemainingHeader = response.getHeaders(\"X-RateLimit-HourRemaining\");\n\n        DateTime headerDate = null;\n        long retMillis=-1;\n\n        if (dateHeader!=null&&dateHeader.length>0) {\n            final String value = dateHeader[0].getValue();\n            if (value!=null) {\n                try {\n                    headerDate = httpResponseDateFormat.parseDateTime(value);\n                } catch(Throwable e) {\n                    logger.warn(\"Could not parse Date Moves API header, its value is [\" + value + \"]\");\n                }\n            }\n        }\n\n        if(headerDate==null) {\n            return -1;\n        }\n\n        if (minuteRemainingHeader!=null&&minuteRemainingHeader.length>0 &&\n            hourRemainingHeader!=null&&hourRemainingHeader.length>0) {\n            final String minuteRemValue = minuteRemainingHeader[0].getValue();\n            final String hourRemValue = hourRemainingHeader[0].getValue();\n            if (minuteRemValue==null || hourRemValue==null) {\n                return -1;\n            }\n            // Determine if either or both of the minute and hour quotas are gone\n            // by comparing their values to \"0\"\n            final boolean hourQuotaGone= hourRemValue.equals(\"0\");\n            final boolean minuteQuotaGone= minuteRemValue.equals(\"0\");\n\n            // At this point we know that minuteRemValue and hourRemValue have non-null values\n            // Compute the top of the minute by setting the seconds of minute for\n            // a copy of headerDate to zero\n            DateTime topOfThisMinute = headerDate.secondOfMinute().setCopy(0);\n\n            if(!minuteQuotaGone && !hourQuotaGone) {\n                // We still have quota left for now, return topOfThisMinute\n                retMillis = topOfThisMinute.getMillis();\n            }\n            else if(hourQuotaGone) {\n                // We need to start again at the top of the next hour\n                DateTime topOfThisHour = topOfThisMinute.minuteOfHour().setCopy(0);\n                DateTime topOfNextHour = topOfThisHour.plusHours(1);\n                retMillis = topOfNextHour.getMillis();\n            }\n            else {\n                // We need to start again at the top of the next minute\n                // However, experimentally it didn't reset quota until ~14 sec after the top of the next minute,\n                // so pad forward by 20 seconds\n                DateTime topOfNextMinutePlusPadding = topOfThisMinute.plusMinutes(1).plusSeconds(20);\n                retMillis = topOfNextMinutePlusPadding.getMillis();\n            }\n\n            long now = System.currentTimeMillis();\n            System.out.println(new StringBuilder().append(\"MOVES: guestId=\").append(updateInfo.getGuestId()).append(\", minuteRem=\").append(minuteRemValue).append(\", hourRem=\").append(hourRemValue).append(\", nextQuotaMillis=\").append(retMillis).append(\" (now=\").append(now).append(\", delta=\").append(retMillis - now).append(\")\").toString());\n        }\n\n        return retMillis;\n    }\n\n\n    // getDatesSince takes argument and returns a list of dates in storage format (yyyy-mm-dd)\n    private static List<String> getDatesSince(String fromDate) {\n        List<String> dates = new ArrayList<String>();\n        DateTime then = TimeUtils.dateFormatterUTC.parseDateTime(fromDate);\n        // TODO: Today should be relative to the timezone the user is in rather than UTC\n        // We could either use the Moves profile TZ or the metadata TZ.  It's not clear which\n        // would be better.\n        String today = TimeUtils.dateFormatterUTC.print(System.currentTimeMillis());\n        DateTime todaysTime = TimeUtils.dateFormatterUTC.parseDateTime(today);\n        if (then.isAfter(todaysTime))\n            throw new IllegalArgumentException(\"fromDate is after today\");\n        while (!today.equals(fromDate)) {\n            dates.add(fromDate);\n            then = TimeUtils.dateFormatterUTC.parseDateTime(fromDate);\n            String date = TimeUtils.dateFormatterUTC.print(then.plusDays(1));\n            fromDate = date;\n        }\n        dates.add(today);\n        return dates;\n    }\n\n    private static String toStorageFormat(String date) {\n        DateTime then = compactDateFormat.withZoneUTC().parseDateTime(date);\n        String storageDate = TimeUtils.dateFormatterUTC.print(then);\n        return storageDate;\n    }\n\n    private String toCompactDateFormat(final String date) {\n        DateTime then = TimeUtils.dateFormatterUTC.parseDateTime(date);\n        String compactDate = compactDateFormat.withZoneUTC().print(then);\n        return compactDate;\n    }\n\n\n    // getDatesBefore assumes its argument is in storage format and returns a list of dates in storage format\n    private List<String> getDatesBefore(String date, int nDays) {\n        DateTime initialDate = TimeUtils.dateFormatterUTC.parseDateTime(date);\n        List<String> dates = new ArrayList<String>();\n        for (int i=0; i<nDays; i++) {\n            initialDate = initialDate.minusDays(1);\n            String nextDate = TimeUtils.dateFormatterUTC.print(initialDate);\n            dates.add(nextDate);\n        }\n        return dates;\n    }\n\n    private String getMaxDateWithDataInDB(UpdateInfo updateInfo) {\n        final String entityName = JPAUtils.getEntityName(MovesPlaceFacet.class);\n        final List<MovesPlaceFacet> newest = jpaDaoService.executeQueryWithLimit(\n                        \"SELECT facet from \" + entityName + \" facet WHERE facet.apiKeyId=? ORDER BY facet.end DESC,facet.date DESC\",\n                        1,\n                        MovesPlaceFacet.class, updateInfo.apiKey.getId());\n\n        // If there are existing moves place facets, return the date of the most recent one.\n        // If there are no existing moves place facets, return null\n        String ret = null;\n        if (newest.size()>0) {\n            ret = newest.get(0).date;\n            System.out.println(\"Moves: guestId=\" + updateInfo.getGuestId() + \", maxDateInDB=\" + ret);\n        }\n        else {\n            System.out.println(\"Moves: guestId=\" + updateInfo.getGuestId() + \", maxDateInDB=null\");\n        }\n        return ret;\n    }\n\n    private String createOrUpdateData(List<String> dates, UpdateInfo updateInfo, boolean withTrackpoints)\n            throws Exception {\n        // Create or update the data for a list of dates.  Returns the date of the latest day with non-empty data,\n        // or null if no dates had data\n\n        // Get the user registration date for comparison.  There's no point in trying to update data from before then.\n        String userRegistrationDate = getUserRegistrationDate(updateInfo);\n        String maxDateWithData=getMaxDateWithDataInDB(updateInfo);\n\n        try {\n            for (String date : dates) {\n                if(date==null || (userRegistrationDate!=null && date.compareTo(userRegistrationDate)<0)) {\n                    // This date is either invalid or would be before the registration date, skip it\n                    continue;\n                }\n                System.out.println(\"MOVES: guestId=\" + updateInfo.getGuestId() + \", moves connector: fetching story line for date \" + date + \", withTrackPoints is \" + withTrackpoints);\n\n                // In the case where we're moving forward in time, record the date we're about to fetch as the\n                // date to start with next time in case we encounter a failure during the update\n                if (withTrackpoints) {\n                   guestService.setApiKeyAttribute(updateInfo.apiKey, updateDateKeyName, date);\n                }\n\n                String fetched = fetchStorylineForDate(updateInfo, date, withTrackpoints);\n\n                if(fetched!=null) {\n                    final JSONArray segments = getSegments(fetched);\n                    if(segments!=null && segments.size()>0) {\n                        boolean dateHasData=createOrUpdateDataForDate(updateInfo, segments, date);\n\n                        // Update maxDateWithData only if there was data for this date\n                        if(dateHasData && (maxDateWithData==null || maxDateWithData.compareTo(date)<0)) {\n                            maxDateWithData = date;\n                        }\n                    }\n                }\n            }\n        }\n        catch (UpdateFailedException e) {\n            // The update failed and whoever threw the error knew enough to have all the details.\n            // Rethrow the error\n            System.out.println(\"MOVES: guestId=\" + updateInfo.getGuestId() + \", UPDATE FAILED\");\n\n            throw e;\n        }\n        catch (RateLimitReachedException e) {\n            // We reached rate limit and whoever threw the error knew enough to have all the details.\n            // Rethrow the error\n            System.out.println(\"MOVES: guestId=\" + updateInfo.getGuestId() + \", RATE LIMIT REACHED\");\n\n            throw e;\n        }\n        catch (Exception e) {\n            StringBuilder sb = new StringBuilder(\"module=updateQueue component=updater action=MovesUpdater.getUserRegistrationDate\")\n                    .append(\" message=\\\"exception while in createOrUpdateData\\\" connector=\")\n                    .append(updateInfo.apiKey.getConnector().toString()).append(\" guestId=\")\n                    .append(updateInfo.apiKey.getGuestId())\n                    .append(\" stackTrace=<![CDATA[\").append(Utils.stackTrace(e)).append(\"]]>\");;\n            logger.info(sb.toString());\n\n            System.out.println(\"MOVES: guestId=\" + updateInfo.getGuestId() + \", UPDATE FAILED (don't know why)\");\n\n            // The update failed.  We don't know if this is permanent or temporary.\n            // Throw the appropriate exception.\n            throw new UpdateFailedException(e);\n        }\n\n        // In the case that maxDateWithData is set to non-null and we're moving forward in time and we completed successfully,\n        // record the maxDateWithData date to start with next time.  This has the unfortunate effect that we may end up\n        // reading in the dates since the user last had access to wireless or since they gave up on Moves many\n        // times.  The alternative would be to potentially fail to update a range of dates that don't have complete\n        // data on the Moves server.  This may set updateDateKeyName to an earlier date than the place above where updateDateKeyName\n        // is set.  This looks a bit strange, but it's the best I could come up with to both handle the\n        // case where the Moves server doesn't have data for the most recent of days and where the\n        // user registration date is set to way before the earliest real data.  In the former case, the above\n        // set of updateDateKeyName will now be overridden with an earlier date.  In the latter case, the\n        // above set or updateDateKeyName will stand as-is and continue moving forward on restarts until we have\n        // seen a date that really has some data.  To prevent excessive updating in the case where a user\n        // has given up on Moves and is really never going to update, limit the setback to a maximum of 7 days.\n        if(withTrackpoints && maxDateWithData!=null) {\n            String dateToStore = maxDateWithData;\n            DateTime maxDateTimeWithData = TimeUtils.dateFormatterUTC.parseDateTime(maxDateWithData);\n            DateTime nowMinusSevenDays = new DateTime().minusDays(7);\n            if(maxDateTimeWithData.isBefore(nowMinusSevenDays)) {\n                // maxDateWithData is too long ago.  Use 7 days ago instead.\n                dateToStore = TimeUtils.dateFormatterUTC.print(nowMinusSevenDays);\n                System.out.println(\"MOVES: guestId=\" + updateInfo.getGuestId() + \", maxDateWithData=\" + maxDateWithData + \" < 7 days ago, using \" + dateToStore);\n            }\n            else {\n                System.out.println(\"MOVES: guestId=\" + updateInfo.getGuestId() + \", storing maxDateWithData=\" + maxDateWithData);\n            }\n            guestService.setApiKeyAttribute(updateInfo.apiKey, updateDateKeyName, dateToStore);\n        }\n\n        return(maxDateWithData);\n    }\n\n    private boolean createOrUpdateDataForDate(final UpdateInfo updateInfo, final JSONArray segments,\n                                           final String date) throws UpdateFailedException {\n        // For a given date, iterate over the JSON array of segments returned by a call to the Moves API and\n        // reconcile them with any previously persisted move and place facets for that date.\n        // A given segment may be either of type move or place.  Either type has an overall\n        // start and end time and may contain a list of activities.  A given segment is considered to match\n        // a stored facet if the type matches (move vs place) and the start time and date match.  If a match is\n        // found, the activities associated with that segment are reconciled.\n        // Returns true if the date has a non empty set of data, false otherwise\n        boolean dateHasData=false;\n\n        // Check that segments and date are both non-null.  If so, continue, otherwise return false\n        if(date==null || segments==null)\n            return false;\n\n        for (int j=0; j<segments.size(); j++) {\n            JSONObject segment = segments.getJSONObject(j);\n            if (segment.getString(\"type\").equals(\"move\")) {\n                if(createOrUpdateMovesMoveFacet(date, segment, updateInfo)!=null)\n                    dateHasData=true;\n            } else if (segment.getString(\"type\").equals(\"place\")) {\n                if(createOrUpdateMovesPlaceFacet(date, segment, updateInfo)!=null)\n                    dateHasData=true;\n            }\n        }\n        return dateHasData;\n    }\n\n    // For a given date and move segment JSON, either create or update the data for a move corresponding to that segment\n    private MovesMoveFacet createOrUpdateMovesMoveFacet(final String date,final JSONObject segment, final UpdateInfo updateInfo)\n        throws UpdateFailedException {\n        try {\n            final DateTime startTime = timeStorageFormat.withZoneUTC().parseDateTime(segment.getString(\"startTime\"));\n            long start = startTime.getMillis();\n\n            MovesMoveFacet ret =\n                    apiDataService.createOrReadModifyWrite(MovesMoveFacet.class,\n                                                           new ApiDataService.FacetQuery(\n                                                                   \"e.apiKeyId = ? AND e.date = ? AND e.start = ?\",\n                                                                   updateInfo.apiKey.getId(),\n                                                                   date,\n                                                                   start),\n                                                           new ApiDataService.FacetModifier<MovesMoveFacet>() {\n                                                               // Throw exception if it turns out we can't make sense of the observation's JSON\n                                                               // This will abort the transaction\n                                                               @Override\n                                                               public MovesMoveFacet createOrModify(MovesMoveFacet facet, Long apiKeyId) {\n                                                                   boolean needsUpdate = false;\n                                                                   // Don't already have a MovesMoveFacet with this apiKeyId, start, and date.  Create one\n                                                                   if (facet == null) {\n                                                                       facet = new MovesMoveFacet(apiKeyId);\n                                                                       facet.guestId = updateInfo.apiKey.getGuestId();\n                                                                       facet.api = updateInfo.apiKey.getConnector().value();\n\n                                                                       // Set the fields based on the JSON and create activities from scratch\n                                                                       extractMoveData(date, segment, facet, updateInfo);\n                                                                       needsUpdate=true;\n                                                                   }\n                                                                   else {\n                                                                       // Already have a MovesMoveFacet with this apiKeyId, start, and date.\n                                                                       // Just update from the segment info\n                                                                       needsUpdate = tidyUpMoveFacet(segment, facet);\n                                                                       needsUpdate |= tidyUpActivities(updateInfo, segment, facet);\n                                                                   }\n\n\n                                                                   // If the facet changed set timeUpdated\n                                                                   if(needsUpdate) {\n                                                                       facet.timeUpdated = System.currentTimeMillis();\n                                                                   }\n\n                                                                   return facet;\n                                                               }\n                                                           }, updateInfo.apiKey.getId());\n            return ret;\n\n        }\n        catch (Throwable e) {\n            // Couldn't makes sense of the move's JSON\n            StringBuilder sb = new StringBuilder(\"module=updateQueue component=updater action=MovesUpdater.createOrUpdateMovesMoveFacet\")\n                    .append(\" message=\\\"exception while processing move segment\\\" connector=\")\n                    .append(updateInfo.apiKey.getConnector().toString()).append(\" guestId=\")\n                    .append(updateInfo.apiKey.getGuestId())\n                    .append(\" stackTrace=<![CDATA[\").append(Utils.stackTrace(e)).append(\"]]>\");;\n            logger.info(sb.toString());\n\n            // The update failed.  We don't know if this is permanent or temporary.\n            // Throw the appropriate exception.\n            throw new UpdateFailedException(e);\n        }\n    }\n\n    // For a given date and place segment JSON, either create or update the data for a place corresponding to that segment\n    private MovesPlaceFacet createOrUpdateMovesPlaceFacet(final String date,final JSONObject segment, final UpdateInfo updateInfo)\n        throws UpdateFailedException{\n        try {\n            final DateTime startTime = timeStorageFormat.withZoneUTC().parseDateTime(segment.getString(\"startTime\"));\n            final long start = startTime.getMillis();\n\n            MovesPlaceFacet ret =\n                    apiDataService.createOrReadModifyWrite(MovesPlaceFacet.class,\n                                                           new ApiDataService.FacetQuery(\n                                                                   \"e.apiKeyId = ? AND e.date = ? AND e.start = ?\",\n                                                                   updateInfo.apiKey.getId(),\n                                                                   date,\n                                                                   start),\n                                                           new ApiDataService.FacetModifier<MovesPlaceFacet>() {\n                                                               // Throw exception if it turns out we can't make sense of the observation's JSON\n                                                               // This will abort the transaction\n                                                               @Override\n                                                               public MovesPlaceFacet createOrModify(MovesPlaceFacet facet, Long apiKeyId) {\n                                                                   boolean needsUpdate = false;\n                                                                   if (facet == null) {\n                                                                       facet = new MovesPlaceFacet(apiKeyId);\n                                                                       facet.guestId = updateInfo.apiKey.getGuestId();\n                                                                       facet.api = updateInfo.apiKey.getConnector().value();\n                                                                       // Set the fields based on the JSON and create activities from scratch\n                                                                       extractMoveData(date, segment, facet, updateInfo);\n                                                                       extractPlaceData(segment, facet);\n                                                                       needsUpdate=true;\n                                                                   }\n                                                                   else {\n                                                                       // Already have a MovesMoveFacet with this apiKeyId, start, and date.\n                                                                       // Just update from the segment info\n                                                                       needsUpdate = tidyUpPlaceFacet(segment, facet);\n                                                                       needsUpdate |= tidyUpActivities(updateInfo, segment, facet);\n                                                                   }\n\n                                                                   // If the facet changed set timeUpdated\n                                                                   if(needsUpdate) {\n                                                                       facet.timeUpdated = System.currentTimeMillis();\n                                                                   }\n                                                                   return facet;\n                                                               }\n                                                           }, updateInfo.apiKey.getId());\n            return ret;\n\n        } catch (Throwable e) {\n            // Couldn't makes sense of the move's JSON\n            StringBuilder sb = new StringBuilder(\"module=updateQueue component=updater action=MovesUpdater.createOrUpdateMovesPlaceFacet\")\n                    .append(\" message=\\\"exception while processing place segment\\\" connector=\")\n                    .append(updateInfo.apiKey.getConnector().toString()).append(\" guestId=\")\n                    .append(updateInfo.apiKey.getGuestId())\n                    .append(\" stackTrace=<![CDATA[\").append(Utils.stackTrace(e)).append(\"]]>\");;\n            logger.info(sb.toString());\n\n            // The update failed.  We don't know if this is permanent or temporary.\n            // Throw the appropriate exception.\n            throw new UpdateFailedException(e);\n        }\n    }\n\n    @Transactional(readOnly=false)\n    private boolean tidyUpActivities(final UpdateInfo updateInfo, final JSONObject segment, final MovesFacet parentFacet) {\n        // Reconcile the stored activities associated with a given parent facet with the contents of a corresponding json\n        // object returned by the Moves API.  Returns true if the facet needs update, and false otherwise.\n        final List<MovesActivity> movesActivities = parentFacet.getActivities();\n        if (!segment.has(\"activities\"))\n            return false;\n        final JSONArray activities = segment.getJSONArray(\"activities\");\n        boolean needsUpdate = false;\n        // TODO: it's possible that the two lists would be of the same length\n        // yet not have perfectly matching start times.  In that case\n        // this function will fail to behave properly.\n        if (movesActivities.size()<activities.size()) {\n            // identify missing activities and add them to the facet's activities\n            addMissingActivities(updateInfo, movesActivities, activities, parentFacet);\n            needsUpdate = true;\n        } else if (movesActivities.size()>activities.size()) {\n            // find out which activities we need to remove\n            removeActivities(movesActivities, activities, parentFacet);\n            needsUpdate = true;\n        }\n        // finally, update activities that need it\n        needsUpdate|=updateActivities(updateInfo, movesActivities, activities);\n        return(needsUpdate);\n    }\n\n    // This function compares start times between a list of stored moves activity facets and entries in a JSON array\n    // of activity objects returned by the Moves API.  Any items in the list of stored facets which do not have a\n    // corresponding item in the JSON array with a matching start time are removed.\n    private void removeActivities(final List<MovesActivity> movesActivities, final JSONArray activities, final MovesFacet facet) {\n        withMovesActivities:for (int i=0; i<movesActivities.size(); i++) {\n            final MovesActivity movesActivity = movesActivities.get(i);\n            for (int j=0; i<activities.size(); i++) {\n                JSONObject activityData = activities.getJSONObject(j);\n                final long start = timeStorageFormat.withZoneUTC().parseDateTime(activityData.getString(\"startTime\")).getMillis();\n                if (movesActivity.start==start) {\n                    continue withMovesActivities;\n                }\n            }\n            facet.removeActivity(movesActivity);\n        }\n    }\n\n    // This function reconciles a list of moves activity facets with a JSON array of activity objects returned by the\n    // Moves API.  This assumes that the lists are of the same length and have matching startTimes.\n    // Returns true if any modifications are made and false otherwise.\n    private boolean updateActivities(final UpdateInfo updateInfo, final List<MovesActivity> movesActivities, final JSONArray activities) {\n        boolean needsUpdate = false;\n        // Loop over the activities JSON array returned by a recent API call to check if each has a corresponding\n        // stored activity facet.  Consider a given stored activity facet and JSON item to match if their\n        // start times are the same.\n        for (int i=0; i<activities.size(); i++) {\n            // Loop over the stored facets in movesActivities to make sure that they take into account\n            // jsonActivity.  Consider a given stored activity facet and JSON item to match if\n            // their start times are the same.\n            JSONObject jsonActivity = activities.getJSONObject(i);\n            for (int j=0; j<movesActivities.size(); j++) {\n                final long start = timeStorageFormat.withZoneUTC().parseDateTime(jsonActivity.getString(\"startTime\")).getMillis();\n                final MovesActivity storedActivityFacet = movesActivities.get(j);\n                if (storedActivityFacet.start==start) {\n                    // Here we know that the storedActivityFacet and jsonActivity started at the same time.\n                    // Check that they end at the same time and have the same type and auxilliary data.\n                    needsUpdate|=updateActivity(updateInfo, storedActivityFacet, jsonActivity);\n                    continue;\n                }\n\n            }\n        }\n        return needsUpdate;\n    }\n\n    // This function reconciles a given moves activity facet with a JSON activity objects returned by the\n    // Moves API.  This assumes that the args have already been confirmed to have matching startTimes.\n    // Returns true if any modifications are made and false otherwise.\n    private boolean updateActivity(final UpdateInfo updateInfo,\n                                   final MovesActivity movesActivity,\n                                   final JSONObject activityData) {\n        boolean needsUpdate = false;\n        final long end = timeStorageFormat.withZoneUTC().parseDateTime(activityData.getString(\"endTime\")).getMillis();\n        if (movesActivity.end!=end) {\n            needsUpdate = true;\n            movesActivity.endTimeStorage = AbstractLocalTimeFacet.timeStorageFormat.print(end);\n            movesActivity.end = end;\n        }\n\n        final String activity = activityData.getString(\"activity\");\n        if (!movesActivity.activity.equals(activity)) {\n            needsUpdate = true;\n            movesActivity.activity = activity;\n        }\n\n        if ((activityData.has(\"steps\")&&movesActivity.steps==null)||\n            (activityData.has(\"steps\")&&movesActivity.steps!=activityData.getInt(\"steps\"))) {\n            needsUpdate = true;\n            movesActivity.steps = activityData.getInt(\"steps\");\n        }\n        if (activityData.getInt(\"distance\")!=movesActivity.distance) {\n            needsUpdate = true;\n            movesActivity.distance = activityData.getInt(\"distance\");\n        }\n        if (activityData.has(\"trackPoints\")) {\n            if (movesActivity.activityURI!=null) {\n                // Anne: I removed the check since there should be no problem with inserting\n                // location points which already exist.  TODO: see if we can do better here\n\n                // note: we don't needs to set needsUpdate to true here as the location data is\n                // not stored with the facet per se, it is stored separately in the LocationFacets table\n                //final long stored = jpaDaoService.executeCount(\"SELECT count(facet) FROM \" +\n                //                                          JPAUtils.getEntityName(LocationFacet.class) +\n                //                                          \" facet WHERE facet.source=\" + LocationFacet.Source.MOVES.ordinal() +\n                //                                          \" AND facet.uri='\" + movesActivity.activityURI + \"'\");\n                //final JSONArray trackPoints = activityData.getJSONArray(\"trackPoints\");\n                //if (stored!=trackPoints.size()) {\n                //    jpaDaoService.execute(\"DELETE facet FROM \" +\n                //                          JPAUtils.getEntityName(LocationFacet.class) +\n                //                          \" facet WHERE facet.source=\" + LocationFacet.Source.MOVES +\n                //                          \" AND facet.uri='\" + movesActivity.activityURI + \"'\");\n                    extractTrackPoints(movesActivity.activityURI, activityData, updateInfo);\n                //}\n            } else {\n                needsUpdate = true; // adding an activityURI means an update is needed\n                // Generate a URI of the form '{wlk,cyc,trp}/UUID'.  The activity field must be set before calling createActivityURI\n                movesActivity.activityURI = createActivityURI(movesActivity);\n                extractTrackPoints(movesActivity.activityURI, activityData, updateInfo);\n            }\n        }\n        return needsUpdate;\n    }\n\n    private String createActivityURI(final MovesActivity movesActivity) {\n        // Generate a URI of the form '{wlk,cyc,trp}/UUID'.  The activity field must be set before calling createActivityURI\n        if(movesActivity.activity!=null) {\n            return(movesActivity.activity + \"/\" + UUID.randomUUID().toString());\n        }\n        else {\n            return null;\n        }\n    }\n    private void addMissingActivities(final UpdateInfo updateInfo,\n                                      final List<MovesActivity> movesActivities,\n                                      final JSONArray activities,\n                                      final MovesFacet parentFacet) {\n        // Loop over the activities JSON array returned by a recent API call to check if each has a corresponding\n        // stored activity facet.  Consider a given stored activity facet and JSON item to match if their\n        // start times are the same.\n        withApiActivities:for (int i=0; i<activities.size(); i++) {\n            JSONObject jsonActivity = activities.getJSONObject(i);\n\n            // Loop over the stored facets in movesActivities to make sure that they take into account\n            // jsonActivity.  Consider a given stored activity facet and JSON item to match if\n            // their start times are the same.\n            for (int j=0; j<movesActivities.size(); j++) {\n                final long start = timeStorageFormat.withZoneUTC().parseDateTime(jsonActivity.getString(\"startTime\")).getMillis();\n                MovesActivity storedActivityFacet = movesActivities.get(j);\n                if (storedActivityFacet.start==start) {\n                    // Here we know that storedActivityFacet and jsonActivity started at the same time.\n                    // A later call to updateActivities will check that they end at the same time,\n                    // have the same type and auxilliary data.  Don't worry about that here.\n                    continue withApiActivities;\n                }\n            }\n\n            // There was no stored activity facet matching the same startTime as jsonActivity.  Extract\n            // the fields from jsonActivityfrom into a new facet and add it to our parent facet.\n            // Use the same date for the activities as is stored with the parent.  This is the date\n            // used to make the request to the Moves API.\n            final MovesActivity activity = extractActivity(parentFacet.date,updateInfo, jsonActivity);\n            parentFacet.addActivity(activity);\n        }\n    }\n\n    @Transactional(readOnly=false)\n    private boolean tidyUpPlaceFacet(final JSONObject segment, final MovesPlaceFacet place) {\n        boolean needsUpdating = false;\n\n        // Check for change in the end time\n        final DateTime endTime = timeStorageFormat.withZoneUTC().parseDateTime(segment.getString(\"endTime\"));\n        if(place.end != endTime.getMillis()) {\n            //System.out.println(place.start + \": endTime changed\");\n            needsUpdating = true;\n            place.end = endTime.getMillis();\n        }\n\n        // Check for change in the place data\n        JSONObject placeData = segment.getJSONObject(\"place\");\n        if (placeData.has(\"id\")&&place.placeId==null) {\n            //System.out.println(place.start + \": now the place has an id\");\n            needsUpdating = true;\n            place.placeId = placeData.getLong(\"id\");\n        }\n        // update the place type\n        String previousPlaceType = place.type;\n        if (!placeData.getString(\"type\").equals(place.type)) {\n            //System.out.println(place.start + \": place type has changed\");\n            needsUpdating = true;\n            place.type = placeData.getString(\"type\");\n        }\n        if (placeData.has(\"name\")&&\n            (place.name==null || !place.name.equals(placeData.getString(\"name\")))) {\n            //System.out.println(place.start + \": place name has changed\");\n            needsUpdating = true;\n            place.name = placeData.getString(\"name\");\n        }\n\n        // if the place wasn't identified previously, store its fourquare info now\n        if (!previousPlaceType.equals(\"foursquare\")&&\n            place.type.equals(\"foursquare\")){\n            //System.out.println(place.start + \": storing foursquare info\");\n            needsUpdating = true;\n            place.foursquareId = placeData.getString(\"foursquareId\");\n        }\n        JSONObject locationData = placeData.getJSONObject(\"location\");\n        float lat = (float) locationData.getDouble(\"lat\");\n        float lon = (float) locationData.getDouble(\"lon\");\n        if (Math.abs(lat-place.latitude)>0.0001 || Math.abs(lon-place.longitude)>0.0001) {\n            //System.out.println(place.start + \": lat/lon have changed\");\n            needsUpdating = true;\n            place.latitude = lat;\n            place.longitude = lon;\n        }\n        return (needsUpdating);\n    }\n\n    @Transactional(readOnly=false)\n    private boolean tidyUpMoveFacet(final JSONObject segment, final MovesFacet moveFacet) {\n        boolean needsUpdating = false;\n\n        // Check for change in the end time\n        final DateTime endTime = timeStorageFormat.withZoneUTC().parseDateTime(segment.getString(\"endTime\"));\n        if(moveFacet.end != endTime.getMillis()) {\n            needsUpdating = true;\n            moveFacet.end = endTime.getMillis();\n        }\n\n        return(needsUpdating);\n    }\n\n    private JSONArray getSegments(final String json) {\n        JSONArray segments = null;\n        try {\n            JSONArray jsonArray = JSONArray.fromObject(json);\n            JSONObject dayFacetData = jsonArray.getJSONObject(0);\n            segments = dayFacetData.getJSONArray(\"segments\");\n        } catch (Throwable t) {\n            // The above code may fail in the case where a day has\n            // no segments.  That's a legitimate result.\n            // In that case, return null.\n        }\n\n        return segments;\n    }\n\n    private List<AbstractFacet> extractFacets(UpdateInfo updateInfo, String json) throws Exception {\n        List<AbstractFacet> facets = new ArrayList<AbstractFacet>();\n        JSONArray jsonArray = JSONArray.fromObject(json);\n        for (int i=0; i<jsonArray.size(); i++) {\n            JSONObject dayFacetData = jsonArray.getJSONObject(i);\n            String date = dayFacetData.getString(\"date\");\n            String dateStorage = toStorageFormat(date);\n            JSONArray segments = dayFacetData.getJSONArray(\"segments\");\n            for (int j=0; j<segments.size(); j++) {\n                JSONObject segment = segments.getJSONObject(j);\n                if (segment.getString(\"type\").equals(\"move\")) {\n                    facets.add(createOrUpdateMovesMoveFacet(dateStorage, segment, updateInfo));\n                    // Old version:\n//                    facets.add(extractMove(dateStorage, segment, updateInfo));\n                } else if (segment.getString(\"type\").equals(\"place\")) {\n                    facets.add(createOrUpdateMovesPlaceFacet(dateStorage, segment, updateInfo));\n                    // Old version:\n//                    facets.add(extractPlace(dateStorage, segment, updateInfo));\n                }\n            }\n        }\n        return facets;\n    }\n\n    private MovesPlaceFacet extractPlace(final String date, final JSONObject segment, UpdateInfo updateInfo) {\n        MovesPlaceFacet facet = new MovesPlaceFacet(updateInfo.apiKey.getId());\n        facet.guestId=updateInfo.getGuestId();\n        facet.date=date;\n        extractMoveData(date, segment, facet, updateInfo);\n        extractPlaceData(segment, facet);\n        return facet;\n    }\n\n    private void extractPlaceData(final JSONObject segment, final MovesPlaceFacet facet) {\n        JSONObject placeData = segment.getJSONObject(\"place\");\n        if (placeData.has(\"id\"))\n            facet.placeId = placeData.getLong(\"id\");\n        facet.type = placeData.getString(\"type\");\n        if (placeData.has(\"name\"))\n            facet.name = placeData.getString(\"name\");\n        else {\n            // ask google\n        }\n        if (facet.type.equals(\"foursquare\"))\n            facet.foursquareId = placeData.getString(\"foursquareId\");\n        JSONObject locationData = placeData.getJSONObject(\"location\");\n        facet.latitude = (float) locationData.getDouble(\"lat\");\n        facet.longitude = (float) locationData.getDouble(\"lon\");\n    }\n\n    private MovesMoveFacet extractMove(final String date, final JSONObject segment, final UpdateInfo updateInfo) {\n        MovesMoveFacet facet = new MovesMoveFacet(updateInfo.apiKey.getId());\n        facet.guestId=updateInfo.getGuestId();\n        facet.date=date;\n        extractMoveData(date, segment, facet, updateInfo);\n        return facet;\n    }\n\n    private void extractMoveData(final String date, final JSONObject segment, final MovesFacet facet, UpdateInfo updateInfo) {\n        facet.date = date;\n        // The times given by Moves are absolute GMT, not local time\n        final DateTime startTime = timeStorageFormat.withZoneUTC().parseDateTime(segment.getString(\"startTime\"));\n        final DateTime endTime = timeStorageFormat.withZoneUTC().parseDateTime(segment.getString(\"endTime\"));\n        facet.start = startTime.getMillis();\n        facet.end = endTime.getMillis();\n        facet.date=date;\n        extractActivities(date, segment, facet, updateInfo);\n    }\n\n    private void extractActivities(final String date, final JSONObject segment, final MovesFacet facet, UpdateInfo updateInfo) {\n        if (!segment.has(\"activities\"))\n            return;\n        final JSONArray activities = segment.getJSONArray(\"activities\");\n        for (int i=0; i<activities.size(); i++) {\n            JSONObject activityData = activities.getJSONObject(i);\n            MovesActivity activity = extractActivity(date, updateInfo, activityData);\n            facet.addActivity(activity);\n        }\n    }\n\n    private MovesActivity extractActivity(final String date, final UpdateInfo updateInfo, final JSONObject activityData) {\n        MovesActivity activity = new MovesActivity();\n        activity.activity = activityData.getString(\"activity\");\n        // Generate a URI of the form '{wlk,cyc,trp}/UUID'.  The activity field must be set before calling createActivityURI\n        activity.activityURI = createActivityURI(activity);\n\n        final DateTime startTime = timeStorageFormat.withZoneUTC().parseDateTime(activityData.getString(\"startTime\"));\n        final DateTime endTime = timeStorageFormat.withZoneUTC().parseDateTime(activityData.getString(\"endTime\"));\n\n        // Note that unlike everywhere else in the sysetm, startTimeStorage and endTimeStorage here are NOT local times.\n        // They are in GMT.\n        activity.startTimeStorage = AbstractLocalTimeFacet.timeStorageFormat.print(startTime);\n        activity.endTimeStorage = AbstractLocalTimeFacet.timeStorageFormat.print(endTime);\n\n        activity.start = startTime.getMillis();\n        activity.end = endTime.getMillis();\n\n        // The date we use here is the date which we used to request this activity from the Moves API\n        activity.date = date;\n\n        if (activityData.has(\"steps\"))\n            activity.steps = activityData.getInt(\"steps\");\n        activity.distance = activityData.getInt(\"distance\");\n        extractTrackPoints(activity.activityURI, activityData, updateInfo);\n        return activity;\n    }\n\n    private void extractTrackPoints(final String activityId, final JSONObject activityData, UpdateInfo updateInfo) {\n        // Check if we actually have trackPoints in this activity data.  If not, return now.\n        if(!activityData.has(\"trackPoints\")) {\n            return;\n        }\n        final JSONArray trackPoints = activityData.getJSONArray(\"trackPoints\");\n        List<LocationFacet> locationFacets = new ArrayList<LocationFacet>();\n        // timeZone is computed based on first location for each batch of trackPoints\n        TimeZone timeZone = null;\n        Connector connector = Connector.getConnector(\"moves\");\n        for (int i=0; i<trackPoints.size(); i++) {\n            JSONObject trackPoint = trackPoints.getJSONObject(i);\n            LocationFacet locationFacet = new LocationFacet(updateInfo.apiKey.getId());\n            locationFacet.latitude = (float) trackPoint.getDouble(\"lat\");\n            locationFacet.longitude = (float) trackPoint.getDouble(\"lon\");\n            // The two lines below would calculate the timezone if we cared, but the\n            // timestamps from Moves are already in GMT, so don't mess with the timezone\n            //if (timeZone==null)\n            //    timeZone = metadataService.getTimeZone(locationFacet.latitude, locationFacet.longitude);\n            final DateTime time = timeStorageFormat.withZoneUTC().parseDateTime(trackPoint.getString(\"time\"));\n            locationFacet.timestampMs = time.getMillis();\n            locationFacet.api = connector.value();\n            locationFacet.start = locationFacet.timestampMs;\n            locationFacet.end = locationFacet.timestampMs;\n            locationFacet.source = LocationFacet.Source.MOVES;\n            locationFacet.apiKeyId = updateInfo.apiKey.getId();\n            locationFacet.uri = activityId;\n            locationFacets.add(locationFacet);\n        }\n        apiDataService.addGuestLocations(updateInfo.getGuestId(), locationFacets);\n    }\n\n\n}\n\n
===================================================================
--- fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesUpdater.java	(date 1388785969000)
+++ fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesUpdater.java	(revision )
@@ -4,14 +4,13 @@
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
+import java.util.Random;
 import java.util.TimeZone;
 import java.util.UUID;
-import java.util.Random;
 import com.fluxtream.aspects.FlxLogger;
 import com.fluxtream.connectors.Connector;
 import com.fluxtream.connectors.annotations.Updater;
 import com.fluxtream.connectors.location.LocationFacet;
-import com.fluxtream.connectors.runkeeper.RunKeeperFitnessActivityFacet;
 import com.fluxtream.connectors.updaters.AbstractUpdater;
 import com.fluxtream.connectors.updaters.RateLimitReachedException;
 import com.fluxtream.connectors.updaters.UpdateFailedException;
@@ -30,7 +29,6 @@
 import com.fluxtream.services.impl.BodyTrackHelper.ChannelStyle;
 import com.fluxtream.services.impl.BodyTrackHelper.MainTimespanStyle;
 import com.fluxtream.services.impl.BodyTrackHelper.TimespanStyle;
-import com.fluxtream.utils.HttpUtils;
 import com.fluxtream.utils.JPAUtils;
 import com.fluxtream.utils.TimeUtils;
 import com.fluxtream.utils.UnexpectedHttpResponseCodeException;
@@ -268,6 +266,7 @@
             channelStyle.timespanStyles.defaultStyle.borderWidth = 2;
             channelStyle.timespanStyles.defaultStyle.top = 0.0;
             channelStyle.timespanStyles.defaultStyle.bottom = 1.0;
+            channelStyle.timespanStyles.defaultStyle.iconURL = "/moves/place/{apiKeyId}/{id}";
             channelStyle.timespanStyles.values = new HashMap();
 
             TimespanStyle stylePart = new TimespanStyle();
Index: fluxtream-core/src/main/java/com/fluxtream/mvc/models/TimespanModel.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.fluxtream.mvc.models;\n\nimport java.util.List;\n\npublic class TimespanModel {\n    double start;\n    double end;\n    String value;\n    String objectType;\n\n    public TimespanModel(long start, long end, String value,String objectType){\n        this.start = start / 1000.0;\n        this.end = end / 1000.0;\n        this.value = value;\n        this.objectType = objectType;\n    }\n}\n
===================================================================
--- fluxtream-core/src/main/java/com/fluxtream/mvc/models/TimespanModel.java	(date 1388785969000)
+++ fluxtream-core/src/main/java/com/fluxtream/mvc/models/TimespanModel.java	(revision )
@@ -1,17 +1,24 @@
 package com.fluxtream.mvc.models;
 
-import java.util.List;
+import java.util.HashMap;
+import java.util.Map;
 
 public class TimespanModel {
     double start;
     double end;
     String value;
     String objectType;
+    Map<String,String> params;
 
     public TimespanModel(long start, long end, String value,String objectType){
         this.start = start / 1000.0;
         this.end = end / 1000.0;
         this.value = value;
         this.objectType = objectType;
+    }
+
+    public void addParam(String key, String value) {
+        if (params==null) params = new HashMap<String,String>();
+        params.put(key, value);
     }
 }
Index: fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.fluxtream.connectors.moves;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport com.fluxtream.Configuration;\nimport com.fluxtream.auth.AuthHelper;\nimport com.fluxtream.connectors.Connector;\nimport com.fluxtream.connectors.controllers.ControllerSupport;\nimport com.fluxtream.connectors.updaters.UpdateFailedException;\nimport com.fluxtream.domain.ApiKey;\nimport com.fluxtream.domain.Guest;\nimport com.fluxtream.domain.Notification;\nimport com.fluxtream.services.GuestService;\nimport com.fluxtream.services.NotificationsService;\nimport com.fluxtream.utils.HttpUtils;\nimport net.sf.json.JSONObject;\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n\n/**\n * User: candide\n * Date: 17/06/13\n * Time: 16:49\n */\n@Controller\n@RequestMapping(value = \"/moves/oauth2\")\npublic class MovesController {\n\n    @Autowired\n    Configuration env;\n\n    @Autowired\n    NotificationsService notificationsService;\n\n    @Autowired\n    GuestService guestService;\n\n    static final Logger logger = Logger.getLogger(MovesController.class);\n\n\n    @RequestMapping(value = \"/token\")\n    public String getToken(HttpServletRequest request) throws IOException, ServletException {\n\n        String redirectUri = getRedirectUri();\n\n        // Check that the redirectUri is going to work\n        final String validRedirectUrl = env.get(\"moves.validRedirectURL\");\n        if (!validRedirectUrl.startsWith(ControllerSupport.getLocationBase(request, env))) {\n            final long guestId = AuthHelper.getGuestId();\n            final String validRedirectBase = getBaseURL(validRedirectUrl);\n            notificationsService.addNamedNotification(guestId, Notification.Type.WARNING, Connector.getConnector(\"moves\").statusNotificationName(),\n                                                      \"Adding a Moves connector only works when logged in through \" + validRedirectBase +\n                                                      \".  You are logged in through \" + ControllerSupport.getLocationBase(request, env) +\n                                                      \".<br>Please re-login via the supported URL or inform your Fluxtream administrator \" +\n                                                      \"that the moves.validRedirectURL setting does not match your needs.\");\n            return \"redirect:/app\";\n        }\n\n        // Here we know that the redirectUri will work\n        String approvalPageUrl = String.format(\"https://api.moves-app.com/oauth/v1/authorize?\" +\n                                               \"redirect_uri=%s&\" +\n                                               \"response_type=code&client_id=%s&\" +\n                                               \"scope=activity location\",\n                                               redirectUri, env.get(\"moves.client.id\"));\n        final String apiKeyIdParameter = request.getParameter(\"apiKeyId\");\n        if (apiKeyIdParameter !=null && !StringUtils.isEmpty(apiKeyIdParameter))\n            approvalPageUrl += \"&state=\" + apiKeyIdParameter;\n\n        return \"redirect:\" + approvalPageUrl;\n    }\n\n    public static String getBaseURL(String url) {\n        try {\n            URI uri = new URI(url);\n            StringBuilder rootURI = new StringBuilder(uri.getScheme()).append(\"://\").append(uri.getHost());\n            if(uri.getPort()!=-1) {\n                rootURI.append(\":\" + uri.getPort());\n            }\n            return (rootURI.toString());\n        }\n        catch (URISyntaxException e) {\n            return null;\n        }\n    }\n\n    private String getRedirectUri() {\n        // TODO: This should be checked against the moves.validRedirectURL property to make\n        // sure that it will work.  Moves only accepts the specific redirect URI's which matches the one\n        // configured for this key.\n        return env.get(\"homeBaseUrl\") + \"moves/oauth2/swapToken\";\n    }\n\n    @RequestMapping(value=\"swapToken\")\n    public String swapToken(HttpServletRequest request) throws Exception {\n        final String errorMessage = request.getParameter(\"error\");\n        final Guest guest = AuthHelper.getGuest();\n        Connector connector = Connector.getConnector(\"moves\");\n        if (errorMessage!=null) {\n            notificationsService.addNamedNotification(guest.getId(),\n                                                      Notification.Type.ERROR, connector.statusNotificationName(),\n                                                      \"There was an error while setting you up with the moves service: \" + errorMessage);\n            return \"redirect:/app\";\n        }\n        final String code = request.getParameter(\"code\");\n\n        Map<String,String> parameters = new HashMap<String,String>();\n        parameters.put(\"grant_type\", \"authorization_code\");\n        parameters.put(\"code\", code);\n        parameters.put(\"client_id\", env.get(\"moves.client.id\"));\n        parameters.put(\"client_secret\", env.get(\"moves.client.secret\"));\n        parameters.put(\"redirect_uri\", getRedirectUri());\n        final String json = HttpUtils.fetch(\"https://api.moves-app.com/oauth/v1/access_token\", parameters);\n\n        JSONObject token = JSONObject.fromObject(json);\n\n        if (token.has(\"error\")) {\n            String errorCode = token.getString(\"error\");\n            notificationsService.addNamedNotification(guest.getId(),\n                                                      Notification.Type.ERROR,\n                                                      connector.statusNotificationName(),\n                                                      errorCode);\n            // NOTE: In the future if we implement renew for the Moves connector\n            // we will potentially need to mark the connector as permanently failed.\n            // The way to do this is to get hold of the existing apiKey and do:\n            //  guestService.setApiKeyStatus(apiKey.getId(), ApiKey.Status.STATUS_PERMANENT_FAILURE, null);\n            return \"redirect:/app\";\n        }\n\n        final String refresh_token = token.getString(\"refresh_token\");\n\n        // Create the entry for this new apiKey in the apiKey table and populate\n        // ApiKeyAttributes with all of the keys fro oauth.properties needed for\n        // subsequent update of this connector instance.\n        ApiKey apiKey;\n        final String stateParameter = request.getParameter(\"state\");\n        if (stateParameter !=null&&!StringUtils.isEmpty(stateParameter)) {\n            long apiKeyId = Long.valueOf(stateParameter);\n            apiKey = guestService.getApiKey(apiKeyId);\n        } else {\n            apiKey = guestService.createApiKey(guest.getId(), Connector.getConnector(\"moves\"));\n        }\n\n        guestService.populateApiKey(apiKey.getId());\n        guestService.setApiKeyAttribute(apiKey,\n                                        \"accessToken\", token.getString(\"access_token\"));\n        guestService.setApiKeyAttribute(apiKey,\n                                        \"tokenExpires\", String.valueOf(System.currentTimeMillis() + (token.getLong(\"expires_in\")*1000)));\n        guestService.setApiKeyAttribute(apiKey,\n                                        \"refreshToken\", refresh_token);\n\n        // Record that this connector is now up\n        guestService.setApiKeyStatus(apiKey.getId(), ApiKey.Status.STATUS_UP, null);\n\n        if (stateParameter !=null&&!StringUtils.isEmpty(stateParameter))\n            return \"redirect:/app/tokenRenewed/moves\";\n        else\n            return \"redirect:/app/from/moves\";\n    }\n\n    String getAccessToken(final ApiKey apiKey) throws Exception {\n        final String expiresString = guestService.getApiKeyAttribute(apiKey, \"tokenExpires\");\n        long expires = Long.valueOf(expiresString);\n        if (expires<System.currentTimeMillis())\n            refreshToken(apiKey);\n        return guestService.getApiKeyAttribute(apiKey, \"accessToken\");\n    }\n\n    private void refreshToken(final ApiKey apiKey) throws Exception, UpdateFailedException {\n        // Check to see if we are running on a mirrored test instance\n        // and should therefore refrain from swapping tokens lest we\n        // invalidate an existing token instance\n        String disableTokenSwap = env.get(\"disableTokenSwap\");\n        Connector connector = Connector.getConnector(\"moves\");\n        if(disableTokenSwap!=null && disableTokenSwap.equals(\"true\")) {\n            String msg = \"**** Skipping refreshToken for moves connector instance because disableTokenSwap is set on this server\";\n                                            ;\n            StringBuilder sb2 = new StringBuilder(\"module=MovesController component=MovesController action=refreshToken apiKeyId=\" + apiKey.getId())\n            \t\t\t    .append(\" message=\\\"\").append(msg).append(\"\\\"\");\n            logger.info(sb2.toString());\n            System.out.println(msg);\n\n            // Notify the user that the tokens need to be manually renewed\n            notificationsService.addNamedNotification(apiKey.getGuestId(), Notification.Type.WARNING, connector.statusNotificationName(),\n                                                      \"Heads Up. This server cannot automatically refresh your Moves authentication tokens.<br>\" +\n                                                      \"Please head to <a href=\\\"javascript:App.manageConnectors()\\\">Manage Connectors</a>,<br>\" +\n                                                      \"scroll to the Moves connector, delete the connector, and re-add<br>\" +\n                                                      \"<p>We apologize for the inconvenience</p>\");\n\n            // Record permanent failure since this connector won't work again until\n            // it is reauthenticated\n            guestService.setApiKeyStatus(apiKey.getId(), ApiKey.Status.STATUS_PERMANENT_FAILURE, null);\n            throw new UpdateFailedException(\"requires token reauthorization\",true);\n        }\n\n        // We're not on a mirrored test server.  Try to swap the expired\n        // access token for a fresh one.  Typically moves access tokens are good for\n        // 180 days from time of issue.\n        String swapTokenUrl = \"https://api.moves-app.com/oauth/v1/access_token\";\n\n        final String refreshToken = guestService.getApiKeyAttribute(apiKey, \"refreshToken\");\n        Map<String,String> params = new HashMap<String,String>();\n        params.put(\"refresh_token\", refreshToken);\n        params.put(\"client_id\", guestService.getApiKeyAttribute(apiKey, \"moves.client.id\"));\n        params.put(\"client_secret\", guestService.getApiKeyAttribute(apiKey, \"moves.client.secret\"));\n        params.put(\"grant_type\", \"refresh_token\");\n\n        String fetched;\n        try {\n            fetched = HttpUtils.fetch(swapTokenUrl, params);\n            // Record that this connector is now up\n            guestService.setApiKeyStatus(apiKey.getId(), ApiKey.Status.STATUS_UP, null);\n        } catch (Exception e) {\n            // Notify the user that the tokens need to be manually renewed\n            notificationsService.addNamedNotification(apiKey.getGuestId(), Notification.Type.WARNING, connector.statusNotificationName(),\n                                                      \"Heads Up. We failed in our attempt to automatically refresh your Moves authentication tokens.<br>\" +\n                                                      \"Please head to <a href=\\\"javascript:App.manageConnectors()\\\">Manage Connectors</a>,<br>\" +\n                                                      \"scroll to the Moves connector, delete the connector, and re-add<br>\" +\n                                                      \"<p>We apologize for the inconvenience</p>\");\n\n            // Record permanent update failure since this connector is never\n            // going to succeed\n            guestService.setApiKeyStatus(apiKey.getId(), ApiKey.Status.STATUS_PERMANENT_FAILURE, null);\n            throw new UpdateFailedException(\"refresh token attempt failed\", e, true);\n        }\n\n        JSONObject token = JSONObject.fromObject(fetched);\n        final long expiresIn = token.getLong(\"expires_in\");\n        final String access_token = token.getString(\"access_token\");\n\n        final long now = System.currentTimeMillis();\n        long tokenExpires = now + (expiresIn*1000);\n\n        guestService.setApiKeyAttribute(apiKey,\n                                        \"accessToken\", access_token);\n        guestService.setApiKeyAttribute(apiKey,\n                                        \"tokenExpires\", String.valueOf(tokenExpires));\n\n    }\n\n\n}\n
===================================================================
--- fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesController.java	(date 1388785969000)
+++ fluxtream-connectors/src/main/java/com/fluxtream/connectors/moves/MovesController.java	(revision )
@@ -4,9 +4,11 @@
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.util.HashMap;
+import java.util.List;
 import java.util.Map;
 import javax.servlet.ServletException;
 import javax.servlet.http.HttpServletRequest;
+import javax.servlet.http.HttpServletResponse;
 import com.fluxtream.Configuration;
 import com.fluxtream.auth.AuthHelper;
 import com.fluxtream.connectors.Connector;
@@ -15,7 +17,10 @@
 import com.fluxtream.domain.ApiKey;
 import com.fluxtream.domain.Guest;
 import com.fluxtream.domain.Notification;
+import com.fluxtream.domain.metadata.FoursquareVenue;
 import com.fluxtream.services.GuestService;
+import com.fluxtream.services.JPADaoService;
+import com.fluxtream.services.MetadataService;
 import com.fluxtream.services.NotificationsService;
 import com.fluxtream.utils.HttpUtils;
 import net.sf.json.JSONObject;
@@ -23,6 +28,7 @@
 import org.apache.log4j.Logger;
 import org.springframework.beans.factory.annotation.Autowired;
 import org.springframework.stereotype.Controller;
+import org.springframework.web.bind.annotation.PathVariable;
 import org.springframework.web.bind.annotation.RequestMapping;
 
 
@@ -32,7 +38,7 @@
  * Time: 16:49
  */
 @Controller
-@RequestMapping(value = "/moves/oauth2")
+@RequestMapping(value = "/moves")
 public class MovesController {
 
     @Autowired
@@ -42,12 +48,18 @@
     NotificationsService notificationsService;
 
     @Autowired
+    MetadataService metadataService;
+
+    @Autowired
     GuestService guestService;
 
+    @Autowired
+    JPADaoService jpaDaoService;
+
     static final Logger logger = Logger.getLogger(MovesController.class);
 
 
-    @RequestMapping(value = "/token")
+    @RequestMapping(value = "/oauth2/token")
     public String getToken(HttpServletRequest request) throws IOException, ServletException {
 
         String redirectUri = getRedirectUri();
@@ -99,7 +111,8 @@
         return env.get("homeBaseUrl") + "moves/oauth2/swapToken";
     }
 
-    @RequestMapping(value="swapToken")
+
+    @RequestMapping(value = "/oauth2/swapToken")
     public String swapToken(HttpServletRequest request) throws Exception {
         final String errorMessage = request.getParameter("error");
         final Guest guest = AuthHelper.getGuest();
@@ -244,6 +257,25 @@
         guestService.setApiKeyAttribute(apiKey,
                                         "tokenExpires", String.valueOf(tokenExpires));
 
+    }
+
+    @RequestMapping(value = "/place/{apiKeyId}/{id}")
+    public void getMovesPlaceIcon(@PathVariable("apiKeyId") long apiKeyId,
+                                  @PathVariable("id") long id,
+                                  HttpServletResponse response) throws IOException {
+        List l = jpaDaoService.executeNativeQuery("SELECT type, foursquareId FROM Facet_MovesPlace WHERE apiKeyId=(?1) AND id=(?2)", apiKeyId, id);
+        if (l==null||l.size()==0)
+            response.sendError(404);
+        final Object[] singleResult = (Object[])l.get(0);
+        String type = (String) singleResult[0];
+        if (type.equals("foursquare")) {
+            String foursquareId = (String) singleResult[1];
+            final FoursquareVenue foursquareVenue = metadataService.getFoursquareVenue(foursquareId);
+            response.sendRedirect(foursquareVenue.categoryIconUrlPrefix + "bg_32" + foursquareVenue.categoryIconUrlSuffix);
+        } else {
+            String homeBaseUrl = env.get("homeBaseUrl");
+            response.sendRedirect(homeBaseUrl+"/images/moves/" + type + ".png");
+        }
     }
 
 
